<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Coping with change</title>
    <link href="src/output.css" rel="stylesheet" />
  </head>
  <body class="min-h-screen bg-white">
    <!-- Header / Navbar -->
    <header
  class="bg-blue-800 text-white shadow-xl fixed w-full top-0 z-50 backdrop-blur-sm transition-all duration-500"
>
  <nav class="container mx-auto px-4 sm:px-6 lg:px-8">
    <div class="flex justify-between items-center h-16 lg:h-20">
      <!-- Logo -->
      <div class="flex items-center space-x-3 min-w-0">
        <div
          class="w-8 h-8 sm:w-10 sm:h-10 bg-blue-200 rounded-lg flex items-center justify-center flex-shrink-0 shadow-md"
        >
          <span class="text-blue-800 font-bold text-sm sm:text-base">SP</span>
        </div>
        <div class="min-w-0">
          <h1
            class="font-bold text-white text-lg sm:text-xl md:text-2xl lg:text-3xl xl:text-4xl truncate"
          >
            <a href="index.html">Software Processes</a>
          </h1>
        </div>
      </div>

      <!-- Responsive Navigation -->
      <ul class="flex space-x-2 sm:space-x-3 md:space-x-4 lg:space-x-6">
        <li>
          <a
            href="Software.html"
            class="px-2 sm:px-3 py-1.5 sm:py-2 rounded-md text-sm sm:text-base font-medium text-white hover:bg-blue-600 transition-all duration-200"
          >
            <span class="hidden sm:inline">Chapter 2.1</span>
            <span class="sm:hidden">2.1</span>
          </a>
        </li>
        <li>
          <a
            href="process-activities.html "
            class="px-2 sm:px-3 py-1.5 sm:py-2 rounded-md text-sm sm:text-base font-medium text-white hover:bg-blue-600 transition-all duration-200"
          >
            <span class="hidden sm:inline">Chapter 2.2</span>
            <span class="sm:hidden">2.2</span>
          </a>
        </li>
        <li>
          <a
            href="Coping-with-change.html"
            class="px-2 sm:px-3 py-1.5 sm:py-2 rounded-md text-sm sm:text-base font-medium text-white hover:bg-blue-600 transition-all duration-200"
          >
            <span class="hidden sm:inline">Chapter 2.3</span>
            <span class="sm:hidden">2.3</span>
          </a>
        </li>
        <li>
          <a
            href="UnfiedProcess.html"
            class="px-2 sm:px-3 py-1.5 sm:py-2 rounded-md text-sm sm:text-base font-medium text-white hover:bg-blue-600 transition-all duration-200"
          >
            <span class="hidden sm:inline">Chapter 2.4</span>
            <span class="sm:hidden">2.4</span>
          </a>
        </li>
      </ul>
    </div>
  </nav>
</header>

<div class="w-screen bg-gradient-to-r from-blue-600 via-blue-500 to-blue-400 text-white py-16 px-4 sm:px-8 lg:px-16 rounded-none shadow-2xl relative overflow-hidden mt-16 lg:mt-20">
  <!-- Animated Background Elements for Banner Feel -->
  <div class="absolute inset-0 bg-blue-700 opacity-20 animate-pulse"></div>
  <div class="absolute top-0 left-0 w-full h-full bg-gradient-to-br from-transparent to-blue-800 opacity-30"></div>
  
  <!-- Content Container -->
  <div class="relative z-10 text-center max-w-4xl mx-auto">
    <h1 class="text-4xl sm:text-5xl lg:text-6xl font-extrabold mb-4 transform animate-bounce" style="animation-delay: 0.2s; animation-fill-mode: forwards;">
      Coping with change
    </h1>
    <div class="w-40 h-2 bg-white mx-auto rounded-full mb-6 transform animate-bounce" style="animation-delay: 0.4s; animation-fill-mode: forwards;"></div>
  </div>
</div>
    <!-- Main Content -->
    <main class=" snap-y snap-mandatory container mx-auto px-4 sm:px-6 lg:px-8 pt-16 lg:pt-20 pb-8">
      <!-- Title -->
    

      <section class="snap-start">
        <article
          class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 mb-8 border border-blue-200"
        >
          <p class="text-blue-800 leading-relaxed mb-6 font-bold text-2xl">
            Change is inevitable in all large software projects.
          </p>
          <p class="text-gray-800 leading-relaxed mb-6">
            The system requirements change as the business procuring the system
            responds to external pressures and management priorities change. As
            new technologies become available, new design and implementation
            possibilities emerge. Therefore whatever software process model is
            used, it is essential that it can accommodate changes to the
            software being developed.
          </p>
        </article>

        <img
          src="/src/assets/images/Figure 2.8.png"
          alt="Diagram showing system evolution"
          class="Cope_img"
        />

        <article class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 mb-8 border border-blue-200">
          <p class="text-gray-800 leading-relaxed mb-6">
            Change adds to the costs of software development because it usually
            means that work that has been completed has to be redone. This is
            called rework. For example, if the relationships between the
            requirements in a system have been analyzed and new requirements are
            then identified, some or all of the requirements analysis has to be
            repeated. It may then be necessary to redesign the system to deliver
            the new requirements, change any programs that have been developed,
            and re-test the system.
          </p>

          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            There are two related approaches that may be used to reduce the
            costs of rework:
          </h4>
          <ul class="list-disc ml-6 space-y-2">
            <li class="text-gray-800">
              Change avoidance, where the software process includes activities
              that can anticipate possible changes before significant rework is
              required. For example, a prototype system may be developed to show
              some key features of the system to customers. They can experiment
              with the prototype and refine their requirements before committing
              to high software production costs.
            </li>
            <li class="text-gray-800">
              Change tolerance, where the process is designed so that changes
              can be accommodated at relatively low cost. This normally involves
              some form of incremental development. Proposed changes may be
              implemented in increments that have not yet been developed. If
              this is impossible, then only a single increment (a small part of
              the system) may have to be altered to incorporate the change.
            </li>
          </ul>

          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            In this section, I discuss two ways of coping with change and
            changing system requirements. These are:
          </h4>
          <ul class="list-disc ml-6 space-y-2">
            <li class="text-gray-800">
              System prototyping, where a version of the system or part of the
              system is developed quickly to check the customer's requirements
              and the feasibility of some design decisions. This supports change
              avoidance as it allows users to experiment with the system before
              delivery and so refine their requirements. The number of
              requirements change proposals made after delivery is therefore
              likely to be reduced.
            </li>
            <li class="text-gray-800">
              Incremental delivery, where system increments are delivered to the
              customer for comment and experimentation. This supports both
              change avoidance and change tolerance. It avoids the premature
              commitment to requirements for the whole system and allows changes
              to be incorporated into later increments at relatively low cost.
            </li>
          </ul>

          <p class="text-gray-800 leading-relaxed mb-6">
            The notion of refactoring, namely improving the structure and
            organization of a program, is also an important mechanism that
            supports change tolerance. I discuss this in Chapter 3, which covers
            agile methods.
          </p>
        </article>

        <article
          class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 mb-8 border border-blue-200 "
        >
          <img
            src="/src/assets/images/Figure 2.9.png"
            alt="Diagram of prototype development process"
            class="Cope_img"
          />

          <p class="text-sm text-gray-800 mt-2 text-center mb-5">
            <strong>Figure 2.9</strong> The process of prototype development
          </p>
          <h2 class="text-2xl font-bold text-blue-800 mb-4">
            2.3.1 Prototyping
          </h2>
          <p class="text-gray-800 leading-relaxed mb-6">
            A prototype is an initial version of a software system that is used
            to demonstrate concepts, try out design options, and find out more
            about the problem and its possible solutions. Rapid, iterative
            development of the prototype is essential so that costs are
            controlled and system stakeholders can experiment with the prototype
            early in the software process.
          </p>
        </article>

        <article  class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 mb-8 border border-blue-200 " >
          
          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            A software prototype can be used in a software development process
            to help anticipate changes that may be required:
          </h4>

          <ul class="list-disc ml-6 space-y-2">
            <li class="text-gray-800">
              In the requirements engineering process, a prototype can help with
              the elicitation and validation of system requirements.
            </li>
            <li class="text-gray-800">
              In the system design process, a prototype can be used to explore
              particular software solutions and to support user interface
              design.
            </li>
          </ul>

          <p class="text-gray-800 leading-relaxed mb-6">
            System prototypes allow users to see how well the system supports
            their work. They may get new ideas for requirements, and find areas
            of strength and weakness in the software. They may then propose new
            system requirements. Furthermore, as the prototype is developed, it
            may reveal errors and omissions in the requirements that have been
            proposed. A function described in a specification may seem useful
            and well defined. However, when that function is combined with other
            functions, users often find that their initial view was incorrect or
            incomplete. The system specification may then be modified to reflect
            their changed understanding of the requirements. A system prototype
            may be used while the system is being designed to carry out design
            experiments to check the feasibility of a proposed design. For
            example, a database design may be prototyped and tested to check
            that it supports efficient data access for the most common user
            queries. Prototyping is also an essential part of the user interface
            design process. Because of the dynamic nature of user interfaces,
            textual descriptions and diagrams are not good enough for expressing
            the user interface requirements. Therefore, rapid prototyping with
            end-user involvement is the only sensible way to develop graphical
            user interfaces for software systems.
          </p>
          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            Developers are sometimes pressured by managers to deliver throwaway
            prototypes, particularly when there are delays in delivering the
            final version of the software. However, this is usually unwise:
          </h4>
          <ul class="list-disc ml-6 space-y-2">
            <li class="text-gray-800">
              It may be impossible to tune the prototype to meet non-functional
              requirements, such as performance, security, robustness, and
              reliability requirements, which were ignored during prototype
              development.
            </li>
            <li class="text-gray-800">
              Rapid change during development inevitably means that the
              prototype is undocumented. The only design specification is the
              prototype code. This is not good enough for long-term maintenance.
            </li>
            <li class="text-gray-800">
              The changes made during prototype development will probably have
              degraded the system structure. The system will be difficult and
              expensive to maintain.
            </li>
            <li class="text-gray-800">
              Organizational quality standards are normally relaxed for
              prototype development
            </li>
          </ul>

          <p class="text-gray-800 leading-relaxed mb-6">
            Prototypes do not have to be executable to be useful. Paper-based
            mock-ups of the system user interface (Rettig, 1994) can be
            effective in helping users refine an interface design and work
            through usage scenarios. These are very cheap to develop and can be
            constructed in a few days. An extension of this technique is a
            Wizard of Oz prototype where only the user interface is developed.
            Users interact with this interface but their requests are passed to
            a person who interprets them and outputs the appropriate response.
          </p>
        </article>

        <article
          class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 mb-8 border border-blue-200"
        >
          <img
            src="/src/assets/images/Figure 2.10.png"
            alt="Diagram of incremental delivery"
            class="Cope_img"
          />
          <p class="text-sm text-gray-800 mt-2">
            <strong>Figure 2.10</strong> Incremental delivery
          </p>

          <h2 class="text-2xl font-bold text-blue-800 mb-4">
            2.3.2 Incremental delivery
          </h2>
          <p class="text-gray-800 leading-relaxed mb-6">
            Incremental delivery (Figure 2.10) is an approach to software
            development where some of the developed increments are delivered to
            the customer and deployed for use in an operational environment. In
            an incremental delivery process, customers identify, in outline, the
            services to be provided by the system. They identify which of the
            services are most important and which are least important to them. A
            number of delivery increments are then defined, with each increment
            providing a sub-set of the system functionality. The allocation of
            services to increments depends on the service priority, with the
            highest-priority services implemented and delivered first.
          </p>

          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            Incremental delivery has a number of advantages:
          </h4>
          <ol class="list-decimal list-inside space-y-3 text-gray-800">
            <li>
              Customers can use the early increments as prototypes and gain
              experience that informs their requirements for later system
              increments. Unlike prototypes, these are part of the real system
              so there is no re-learning when the complete system is available.
            </li>
            <li>
              Customers do not have to wait until the entire system is delivered
              before they can gain value from it. The first increment satisfies
              their most critical requirements so they can use the software
              immediately.
            </li>
            <li>
              The process maintains the benefits of incremental development in
              that it should be relatively easy to incorporate changes into the
              system.
            </li>
            <li>
              As the highest-priority services are delivered first and
              increments then integrated, the most important system services
              receive the most testing. This means that customers are less
              likely to encounter software failures in the most important parts
              of the system.
            </li>
          </ol>

          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            However, there are problems with incremental delivery:
          </h4>
          <ul class="list-disc ml-6 space-y-2">
            <li class="text-gray-800">
              Most systems require a set of basic facilities that are used by
              different parts of the system. As requirements are not defined in
              detail until an increment is to be implemented, it can be hard to
              identify common facilities that are needed by all increments.
            </li>
            <li class="text-gray-800">
              Iterative development can also be difficult when a replacement
              system is being developed. Users want all of the functionality of
              the old system and are often unwilling to experiment with an
              incomplete new system. Therefore, getting useful customer feedback
              is difficult.
            </li>
          </ul>

          <p class="text-gray-800 leading-relaxed mb-6">
            There are some types of system where incremental development and
            delivery is not the best approach. These are very large systems
            where development may involve teams working in different locations,
            some embedded systems where the software depends on hardware
            development and some critical systems where all the requirements
            must be analyzed to check for interactions that may compromise the
            safety or security of the system. These systems, of course, suffer
            from the same problems of uncertain and changing requirements.
            Therefore, to address these problems and get some of the benefits of
            incremental development, a process may be used in which a system
            prototype is developed iteratively and used as a platform for
            experiments with the system requirements and design. With the
            experience gained from the prototype, definitive requirements can
            then be agreed.
          </p>
        </article>

        <article
          class="bg-white rounded-2xl shadow-xl p-6 sm:p-8 mb-8 border border-blue-200"
        >
          <img
            src="/src/assets/images/Figure 2. 11.png"
            alt="Boehm's spiral model diagram"
            class="Cope_img"
          />
          <p class="text-sm text-gray-800 mt-2">
            <strong>Figure 2.11</strong> Boehm’s spiral model of the software
            process (©IEEE 1988)
          </p>

          <h2 class="text-2xl font-bold text-blue-800 mb-4">
            2.3.3 Boehm’s spiral model
          </h2>
          <p class="text-gray-800 leading-relaxed mb-6">
            A risk-driven software process framework (the spiral model) was
            proposed by Boehm (1988). This is shown in Figure 2.11. Here, the
            software process is represented as a spiral, rather than a sequence
            of activities with some backtracking from one activity to another.
            Each loop in the spiral represents a phase of the software process.
            Thus, the innermost loop might be concerned with system feasibility,
            the next loop with requirements definition, the next loop with
            system design, and so on. The spiral model combines change avoidance
            with change tolerance. It assumes that changes are a result of
            project risks and includes explicit risk management activities to
            reduce these risks.
          </p>

          <h4 class="text-xl font-semibold text-blue-800 mb-4">
            Each loop in the spiral is split into four sectors:
          </h4>
          <ul class="list-disc ml-6 space-y-2">
            <li class="text-gray-800">
              <strong>Objective setting</strong> Specific objectives for that
              phase of the project are defined. Constraints on the process and
              the product are identified and a detailed management plan is drawn
              up. Project risks are identified. Alternative strategies,
              depending on these risks,
            </li>
            <li>
              <strong>Risk assessment and reduction</strong> For each of the identified project
              risks, a detailed analysis is carried out. Steps are taken to
              reduce the risk. For example, if there is a risk that the
              requirements are inappropriate, a prototype system may be
              developed.
            </li>
            <li>
              <strong>Development and validation</strong> After risk evaluation, a development
              model for the system is chosen. For example, throwaway prototyping
              may be the best development approach if user interface risks are
              dominant. If safety risks are the main consideration, development
              based on formal transformations may be the most appropriate
              process, and so on. If the main identified risk is sub-system
              integration, the waterfall model may be the best development model
              to use.
            </li>
            <li>
              <strong>Planning</strong> The project is reviewed and a decision made whether to
              continue with a further loop of the spiral. If it is decided to
              continue, plans are drawn up for the next phase of the project.
            </li>
          </ul>

          <p>
            The main difference between the spiral model and other software
            process models is its explicit recognition of risk. A cycle of the
            spiral begins by elaborating objectives such as performance and
            functionality. Alternative ways of achieving these objectives, and
            dealing with the constraints on each of them, are then enumerated.
            Each alternative is assessed against each objective and sources of
            project risk are identified. The next step is to resolve these risks
            by information-gathering activities such as more detailed analysis,
            prototyping, and simulation. Once risks have been assessed, some
            development is carried out, followed by a planning activity for the
            next phase of the process. Informally, risk simply means something
            that can go wrong. For example, if the intention is to use a new
            programming language, a risk is that the available compilers are
            unreliable or do not produce sufficiently efficient object code.
            Risks lead to proposed software changes and project problems such as
            schedule and cost overrun, so risk minimization is a very important
            project management activity. Risk management, an essential part of
            project management, is covered in Chapter 22.
          </p>
        </article>

        <!-- Other articles preserved -->
      </section>
    </main>

    <!-- Footer -->
    <footer
      class="bg-gradient-to-br from-blue-800 to-blue-500 text-white shadow-inner"
    >
      <div
        class="container mx-auto px-4 py-12 grid md:grid-cols-2 lg:grid-cols-3 gap-8"
      >
        <!-- Members -->
        <div class="bg-white/10 rounded-2xl p-6">
          <h3 class="font-bold text-xl text-white mb-4">SISTIM MEMBERS</h3>
          <ul class="space-y-2 text-blue-200">
            <li>Mark Angelo G. Patal</li>
            <li>Isabella Grace M. Elola</li>
            <li>Mat Jannus S. De Guzman</li>
            <li>Hazel V. Laguras</li>
          </ul>
        </div>

        <!-- Quick Links -->
        <div class="bg-white/10 rounded-2xl p-6">
          <h3 class="font-bold text-xl text-white mb-4">Quick Navigation</h3>
          <ul class="space-y-2 text-blue-200">
            <li>
              <a href="/Software.html" class="hover:text-white">Chapter 2.1</a>
            </li>
            <li>
              <a href="/process activities.html" class="hover:text-white"
                >Chapter 2.2</a
              >
            </li>
            <li>
              <a href="/Coping with change.html" class="hover:text-white"
                >Chapter 2.3</a
              >
            </li>
            <li>
              <a href="/UnfiedProcess.html" class="hover:text-white"
                >Chapter 2.4</a
              >
            </li>
          </ul>
        </div>

        <!-- Course Info -->
        <div class="bg-white/10 rounded-2xl p-6">
          <h3 class="font-bold text-xl text-white mb-4">Course Info</h3>
          <p class="text-blue-200">Software Engineering</p>
          <p class="text-blue-200">Chapter 2: Software Processes</p>
          <p class="text-blue-200">Academic Year: 2025</p>
        </div>
      </div>

      <div
        class="border-t border-blue-500 pt-6 text-center text-blue-200 text-sm"
      >
        © 2025 SISTIM. Built with passion for software engineering education.
      </div>
    </footer>

    <!-- Script for mobile toggle -->

  </body>
</html>
